{"version":3,"file":"parse.js","names":["generateStyleTextWithExpressionPlaceholders","node","sourceAsString","styleText","expressionStrings","i","quasi","quasis","length","template","expr","expressions","nextTemplate","value","raw","range","exprText","slice","createPlaceholder","push","getDeindentedStyleTextAndOffsets","baseIndentation","loc","end","column","sourceLines","split","baseIndentations","Map","indentationPattern","RegExp","emptyLinePattern","deindentedLines","prefixOffsets","lines","offset","undefined","test","shift","sourceLine","replace","set","deindentedStyleText","join","parse","source","opts","doc","Document","toString","ast","babelParse","sourceType","plugins","ranges","extractedStyles","Set","traverse","TaggedTemplateExpression","path","tag","type","name","includes","add","object","currentOffset","startIndex","root","postcssParse","map","raws","linariaPrefixOffsets","linariaTemplateExpressions","linariaBaseIndentations","beforeStart","codeBefore","parent","document","walker","locationCorrectionWalker","walk","nodes","last","codeAfter","input","Input","start","line"],"sources":["../src/parse.ts"],"sourcesContent":["import { parse as babelParse } from '@babel/parser';\nimport type { NodePath } from '@babel/traverse';\nimport traverse from '@babel/traverse';\nimport type { Identifier, TaggedTemplateExpression } from '@babel/types';\nimport type { Parser, Root, ProcessOptions } from 'postcss';\nimport { Document, Input } from 'postcss';\nimport postcssParse from 'postcss/lib/parse';\n\nimport { locationCorrectionWalker } from './locationCorrection';\nimport { createPlaceholder } from './util';\n\n// This function returns\n// 1) styleText with placeholders for the expressions.\n//    for example:\n//      `${selector} { ${property} : ${value} }`\n//    becomes\n//      `.pcss-lin0 { --pcss-lin1: pcss-lin2 }`\n// 2) an array of the expressions:\n// ['${selector}', '${property}', '${value}']\nconst generateStyleTextWithExpressionPlaceholders = (\n  node: TaggedTemplateExpression,\n  sourceAsString: string\n): { styleText: string; expressionStrings: string[] } => {\n  let styleText = '';\n  const expressionStrings: string[] = [];\n\n  for (let i = 0; i < node.quasi.quasis.length; i++) {\n    const template = node.quasi.quasis[i];\n    const expr = node.quasi.expressions[i];\n    const nextTemplate = node.quasi.quasis[i + 1];\n    if (template) {\n      styleText += template.value.raw;\n\n      if (expr && nextTemplate && nextTemplate.range && template.range) {\n        const exprText = sourceAsString.slice(\n          template.range[1],\n          nextTemplate.range[0]\n        );\n        styleText += createPlaceholder(\n          i,\n          sourceAsString,\n          nextTemplate.range[0]\n        );\n        expressionStrings.push(exprText);\n      }\n    }\n  }\n  return { styleText, expressionStrings };\n};\n\nconst getDeindentedStyleTextAndOffsets = (\n  styleText: string,\n  node: TaggedTemplateExpression\n) => {\n  const baseIndentation = (node.quasi.loc?.end.column ?? 1) - 1;\n  const sourceLines = styleText.split('\\n');\n  const baseIndentations = new Map<number, number>();\n  const indentationPattern = new RegExp(`^[ \\\\t]{${baseIndentation}}`);\n  const emptyLinePattern = /^[ \\\\t\\r]*$/;\n  const deindentedLines: string[] = [];\n  const prefixOffsets = { lines: 0, offset: 0 };\n\n  // remove the first line if it's an empty string and update the prefix\n  // offset to be the lines 1 instead of lines 0\n  if (\n    sourceLines.length > 1 &&\n    sourceLines[0] !== undefined &&\n    emptyLinePattern.test(sourceLines[0])\n  ) {\n    prefixOffsets.lines = 1;\n    prefixOffsets.offset = sourceLines[0].length + 1;\n    sourceLines.shift();\n  }\n\n  // go through each source line and deindent lines\n  for (let i = 0; i < sourceLines.length; i++) {\n    const sourceLine = sourceLines[i];\n    if (sourceLine !== undefined) {\n      // if the sourceline has the indentation pattern\n      if (indentationPattern.test(sourceLine)) {\n        deindentedLines.push(sourceLine.replace(indentationPattern, ''));\n        baseIndentations.set(i + 1, baseIndentation);\n        // Roots don't have an end line, so we can't look this up so easily\n        // later on. Having a special '-1' key helps here.\n        if (i === sourceLines.length - 1) {\n          baseIndentations.set(-1, baseIndentation);\n        }\n      } else {\n        deindentedLines.push(sourceLine);\n      }\n    }\n  }\n\n  const deindentedStyleText = deindentedLines.join('\\n');\n  return { deindentedStyleText, prefixOffsets, baseIndentations };\n};\n\n/**\n * Parses CSS from within tagged template literals in a JavaScript document\n * @param {string} source Source code to parse\n * @param {*=} opts Options to pass to PostCSS' parser when parsing\n * @return {Root|Document}\n */\nexport const parse: Parser<Root | Document> = (\n  source: string | { toString(): string },\n  opts?: Pick<ProcessOptions, 'map' | 'from'>\n): Root | Document => {\n  const doc = new Document();\n  const sourceAsString = source.toString();\n\n  // avoid error spam (and vscode error toasts) if babel can't parse doc\n  // allows user to type new code without constant warnings\n  let ast;\n  try {\n    ast = babelParse(sourceAsString, {\n      sourceType: 'unambiguous',\n      plugins: ['typescript', 'jsx'],\n      ranges: true,\n    });\n  } catch {\n    return doc;\n  }\n  const extractedStyles = new Set<TaggedTemplateExpression>();\n\n  traverse(ast, {\n    TaggedTemplateExpression: (\n      path: NodePath<TaggedTemplateExpression>\n    ): void => {\n      if (\n        path.node.tag.type === 'Identifier' &&\n        path.node.tag.name.includes('css')\n      ) {\n        extractedStyles.add(path.node);\n      }\n\n      if (path.node.tag.type === 'MemberExpression') {\n        if ((path.node.tag.object as Identifier).name === 'styled') {\n          extractedStyles.add(path.node);\n        }\n      }\n    },\n  });\n\n  let currentOffset = 0;\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const node of extractedStyles) {\n    if (!node.quasi.range) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    const startIndex = node.quasi.range[0] + 1;\n\n    const { styleText, expressionStrings } =\n      generateStyleTextWithExpressionPlaceholders(node, sourceAsString);\n\n    const { deindentedStyleText, prefixOffsets, baseIndentations } =\n      getDeindentedStyleTextAndOffsets(styleText, node);\n\n    const root = postcssParse(deindentedStyleText, {\n      ...opts,\n      map: false,\n    }) as Root;\n\n    root.raws.linariaPrefixOffsets = prefixOffsets;\n    root.raws.linariaTemplateExpressions = expressionStrings;\n    root.raws.linariaBaseIndentations = baseIndentations;\n    // TODO: remove this if stylelint/stylelint#5767 ever gets fixed,\n    // or they drop the indentation rule. Their indentation rule depends on\n    // `beforeStart` existing as they unsafely try to call `endsWith` on it.\n    if (!root.raws.beforeStart) {\n      root.raws.beforeStart = '';\n    }\n    root.raws.codeBefore = sourceAsString.slice(\n      currentOffset,\n      startIndex + prefixOffsets.offset\n    );\n    root.parent = doc;\n    // TODO: stylelint relies on this existing, really unsure why.\n    // it could just access root.parent to get the document...\n    (root as Root & { document: Document }).document = doc;\n    const walker = locationCorrectionWalker(node, sourceAsString);\n    walker(root);\n    root.walk(walker);\n    doc.nodes.push(root);\n\n    currentOffset = node.quasi.range[1] - 1;\n  }\n\n  if (doc.nodes.length > 0) {\n    const last = doc.nodes[doc.nodes.length - 1];\n    if (last) {\n      last.raws.codeAfter = sourceAsString.slice(currentOffset);\n    }\n  }\n\n  doc.source = {\n    input: new Input(sourceAsString, opts),\n    start: {\n      line: 1,\n      column: 1,\n      offset: 0,\n    },\n  };\n\n  return doc;\n};\n"],"mappings":"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"}