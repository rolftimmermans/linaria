{"version":3,"file":"locationCorrection.js","names":["correctLocation","node","loc","baseIndentations","sourceAsString","prefixOffsets","quasi","range","baseIndentation","get","line","nodeLoc","nodeOffset","lineOffset","start","newOffset","offset","currentLine","columnOffset","column","lines","i","expressions","length","expr","previousQuasi","quasis","nextQuasi","placeholderSize","createPlaceholder","exprSize","exprStartLine","end","exprEndLine","indentationOffset","computeCorrectedString","value","lineNumber","includes","undefined","repeat","split","rawLines","push","currentLineNumber","join","computeCorrectedRawValue","key","source","computeBeforeAfter","raws","before","parent","type","numBeforeLines","corrected","linariaBefore","after","numAfterLines","nodes","linariaAfter","between","linariaBetween","selector","rawValue","linariaSelector","linariaValue","params","linariaParams","locationCorrectionWalker","root","linariaBaseIndentations","linariaPrefixOffsets"],"sources":["../src/locationCorrection.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport type { TaggedTemplateExpression } from '@babel/types';\nimport type { Root, Position, Document, ChildNode, AnyNode } from 'postcss';\n\nimport { createPlaceholder } from './util';\n\nconst correctLocation = (\n  node: TaggedTemplateExpression,\n  loc: Position,\n  baseIndentations: Map<number, number>,\n  sourceAsString: string,\n  prefixOffsets?: { lines: number; offset: number }\n): Position => {\n  if (!node.quasi.loc || !node.quasi.range) {\n    return loc;\n  }\n\n  const baseIndentation = baseIndentations?.get(loc.line) ?? 0;\n  const nodeLoc = node.quasi.loc;\n  const nodeOffset = node.quasi.range[0];\n  let lineOffset = nodeLoc.start.line - 1;\n  let newOffset = loc.offset + nodeOffset + 1;\n  let currentLine = 1;\n  let columnOffset = nodeLoc.start.column + 1;\n\n  if (prefixOffsets) {\n    lineOffset += prefixOffsets.lines;\n    newOffset += prefixOffsets.offset;\n  }\n\n  for (let i = 0; i < node.quasi.expressions.length; i++) {\n    const expr = node.quasi.expressions[i];\n    const previousQuasi = node.quasi.quasis[i];\n    const nextQuasi = node.quasi.quasis[i + 1];\n\n    if (\n      expr &&\n      expr.loc &&\n      expr.range &&\n      nextQuasi &&\n      previousQuasi &&\n      previousQuasi.loc &&\n      nextQuasi.loc &&\n      previousQuasi.range &&\n      nextQuasi.range &&\n      previousQuasi.range[1] < newOffset\n    ) {\n      const placeholderSize = createPlaceholder(\n        i,\n        sourceAsString,\n        nextQuasi.range[0]\n      ).length;\n      const exprSize =\n        nextQuasi.range[0] - previousQuasi.range[1] - placeholderSize;\n      const exprStartLine = previousQuasi.loc.end.line;\n      const exprEndLine = nextQuasi.loc.start.line;\n      newOffset += exprSize;\n      lineOffset += exprEndLine - exprStartLine;\n\n      if (currentLine !== exprEndLine) {\n        currentLine = exprEndLine;\n        if (exprStartLine === exprEndLine) {\n          columnOffset = exprSize;\n        } else {\n          columnOffset =\n            nextQuasi.loc.start.column -\n            previousQuasi.loc.end.column -\n            placeholderSize;\n        }\n      } else {\n        columnOffset += exprSize;\n      }\n    }\n  }\n\n  let indentationOffset = 0;\n\n  if (baseIndentations) {\n    for (let i = 1; i <= loc.line; i++) {\n      indentationOffset += baseIndentations.get(i) ?? 0;\n    }\n  }\n\n  loc.line += lineOffset;\n  if (loc.line === currentLine) {\n    loc.column += columnOffset;\n  }\n  loc.column += baseIndentation;\n\n  loc.offset = newOffset + indentationOffset;\n\n  return loc;\n};\n\n/**\n * Computes the re-indented string of a given string on a given line\n * @param {string} value Value to re-indent\n * @param {number} lineNumber Current line number of the value\n * @param {Map=} baseIndentations Indentation map\n * @return {string}\n */\nfunction computeCorrectedString(\n  value: string,\n  lineNumber: number,\n  baseIndentations?: Map<number, number>\n): string {\n  if (!value.includes('\\n')) {\n    const baseIndentation = baseIndentations?.get(lineNumber);\n    if (baseIndentation !== undefined) {\n      return ' '.repeat(baseIndentation) + value;\n    }\n    return value;\n  }\n\n  const lines = value.split('\\n');\n  const rawLines: string[] = [];\n\n  if (lines[0] !== undefined) {\n    rawLines.push(lines[0]);\n  }\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    if (line !== undefined) {\n      const currentLineNumber = lineNumber + i;\n      const baseIndentation = baseIndentations?.get(currentLineNumber);\n\n      if (baseIndentation !== undefined) {\n        rawLines.push(' '.repeat(baseIndentation) + line);\n      } else {\n        rawLines.push(line);\n      }\n    }\n  }\n\n  return rawLines.join('\\n');\n}\n\n/**\n * Computes the re-indented value of a given node's raw value\n * @param {T} node Node to re-indent raw value of\n * @param {string} key Raw value key to re-indent\n * @param {Map=} baseIndentations Indentation map\n * @return {string|null}\n */\nfunction computeCorrectedRawValue<T extends AnyNode>(\n  node: T,\n  key: keyof T,\n  baseIndentations?: Map<number, number>\n): string | null {\n  const value = node[key];\n\n  if (typeof value !== 'string' || !node.source?.start) {\n    return null;\n  }\n\n  return computeCorrectedString(\n    value,\n    node.source.start.line,\n    baseIndentations\n  );\n}\n\n/**\n * Computes the before/after strings from the original source for\n * restoration later when stringifying.\n * @param {Document|Root|ChildNode} node Node to compute strings for\n * @param {Map} baseIndentations Map of base indentations by line\n * @return {void}\n */\nfunction computeBeforeAfter(\n  node: Document | Root | ChildNode,\n  baseIndentations: Map<number, number>\n): void {\n  if (\n    node.raws.before &&\n    (node.raws.before.includes('\\n') || node.parent?.type === 'root') &&\n    node.source?.start\n  ) {\n    const numBeforeLines = node.raws.before.split('\\n').length - 1;\n    const corrected = computeCorrectedString(\n      node.raws.before,\n      node.source.start.line - numBeforeLines,\n      baseIndentations\n    );\n    node.raws.linariaBefore = corrected;\n  }\n\n  if (\n    node.raws.after &&\n    node.raws.after.includes('\\n') &&\n    (node.type === 'root' || node.source?.end)\n  ) {\n    const numAfterLines = node.raws.after.split('\\n').length - 1;\n    const line =\n      node.type === 'root'\n        ? node.nodes[node.nodes.length - 1]?.source?.end?.line\n        : node.source?.end?.line;\n    if (line !== undefined) {\n      const corrected = computeCorrectedString(\n        node.raws.after,\n        line - numAfterLines,\n        baseIndentations\n      );\n      node.raws.linariaAfter = corrected;\n    }\n  }\n\n  if (\n    node.raws.between &&\n    node.raws.between.includes('\\n') &&\n    node.source?.start\n  ) {\n    const corrected = computeCorrectedString(\n      node.raws.between,\n      node.source.start.line,\n      baseIndentations\n    );\n\n    node.raws.linariaBetween = corrected;\n  }\n\n  if (node.type === 'rule' && node.selector.includes('\\n')) {\n    const rawValue = computeCorrectedRawValue(\n      node,\n      'selector',\n      baseIndentations\n    );\n\n    if (rawValue !== null) {\n      (node.raws as unknown as Record<string, unknown>).linariaSelector =\n        rawValue;\n    }\n  }\n\n  if (node.type === 'decl' && node.value.includes('\\n')) {\n    const rawValue = computeCorrectedRawValue(node, 'value', baseIndentations);\n\n    if (rawValue !== null) {\n      (node.raws as unknown as Record<string, unknown>).linariaValue = rawValue;\n    }\n  }\n\n  if (node.type === 'atrule' && node.params.includes('\\n')) {\n    const rawValue = computeCorrectedRawValue(node, 'params', baseIndentations);\n\n    if (rawValue !== null) {\n      (node.raws as unknown as Record<string, unknown>).linariaParams =\n        rawValue;\n    }\n  }\n}\n\n/**\n * Creates an AST walker/visitor for correcting PostCSS AST locations to\n * those in the original JavaScript document.\n * @param {TaggedTemplateExpression} expr Expression the original source came\n * from\n * @return {Function}\n */\nexport function locationCorrectionWalker(\n  expr: TaggedTemplateExpression,\n  sourceAsString: string\n): (node: Document | Root | ChildNode) => void {\n  return (node: Document | Root | ChildNode): void => {\n    const root = node.root();\n    const baseIndentations = root.raws.linariaBaseIndentations;\n\n    if (baseIndentations) {\n      computeBeforeAfter(node, baseIndentations);\n    }\n\n    if (node.source?.start) {\n      node.source.start = correctLocation(\n        expr,\n        node.source.start,\n        baseIndentations,\n        sourceAsString,\n        root.raws.linariaPrefixOffsets\n      );\n    }\n    if (node.source?.end) {\n      node.source.end = correctLocation(\n        expr,\n        node.source.end,\n        baseIndentations,\n        sourceAsString,\n        root.raws.linariaPrefixOffsets\n      );\n    }\n  };\n}\n"],"mappings":";;;;;;AAIA;AAJA;;AAMA,MAAMA,eAAe,GAAG,CACtBC,IAA8B,EAC9BC,GAAa,EACbC,gBAAqC,EACrCC,cAAsB,EACtBC,aAAiD,KACpC;EAAA;EACb,IAAI,CAACJ,IAAI,CAACK,KAAK,CAACJ,GAAG,IAAI,CAACD,IAAI,CAACK,KAAK,CAACC,KAAK,EAAE;IACxC,OAAOL,GAAG;EACZ;EAEA,MAAMM,eAAe,4BAAGL,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEM,GAAG,CAACP,GAAG,CAACQ,IAAI,CAAC,yEAAI,CAAC;EAC5D,MAAMC,OAAO,GAAGV,IAAI,CAACK,KAAK,CAACJ,GAAG;EAC9B,MAAMU,UAAU,GAAGX,IAAI,CAACK,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC;EACtC,IAAIM,UAAU,GAAGF,OAAO,CAACG,KAAK,CAACJ,IAAI,GAAG,CAAC;EACvC,IAAIK,SAAS,GAAGb,GAAG,CAACc,MAAM,GAAGJ,UAAU,GAAG,CAAC;EAC3C,IAAIK,WAAW,GAAG,CAAC;EACnB,IAAIC,YAAY,GAAGP,OAAO,CAACG,KAAK,CAACK,MAAM,GAAG,CAAC;EAE3C,IAAId,aAAa,EAAE;IACjBQ,UAAU,IAAIR,aAAa,CAACe,KAAK;IACjCL,SAAS,IAAIV,aAAa,CAACW,MAAM;EACnC;EAEA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,IAAI,CAACK,KAAK,CAACgB,WAAW,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IACtD,MAAMG,IAAI,GAAGvB,IAAI,CAACK,KAAK,CAACgB,WAAW,CAACD,CAAC,CAAC;IACtC,MAAMI,aAAa,GAAGxB,IAAI,CAACK,KAAK,CAACoB,MAAM,CAACL,CAAC,CAAC;IAC1C,MAAMM,SAAS,GAAG1B,IAAI,CAACK,KAAK,CAACoB,MAAM,CAACL,CAAC,GAAG,CAAC,CAAC;IAE1C,IACEG,IAAI,IACJA,IAAI,CAACtB,GAAG,IACRsB,IAAI,CAACjB,KAAK,IACVoB,SAAS,IACTF,aAAa,IACbA,aAAa,CAACvB,GAAG,IACjByB,SAAS,CAACzB,GAAG,IACbuB,aAAa,CAAClB,KAAK,IACnBoB,SAAS,CAACpB,KAAK,IACfkB,aAAa,CAAClB,KAAK,CAAC,CAAC,CAAC,GAAGQ,SAAS,EAClC;MACA,MAAMa,eAAe,GAAG,IAAAC,uBAAiB,EACvCR,CAAC,EACDjB,cAAc,EACduB,SAAS,CAACpB,KAAK,CAAC,CAAC,CAAC,CACnB,CAACgB,MAAM;MACR,MAAMO,QAAQ,GACZH,SAAS,CAACpB,KAAK,CAAC,CAAC,CAAC,GAAGkB,aAAa,CAAClB,KAAK,CAAC,CAAC,CAAC,GAAGqB,eAAe;MAC/D,MAAMG,aAAa,GAAGN,aAAa,CAACvB,GAAG,CAAC8B,GAAG,CAACtB,IAAI;MAChD,MAAMuB,WAAW,GAAGN,SAAS,CAACzB,GAAG,CAACY,KAAK,CAACJ,IAAI;MAC5CK,SAAS,IAAIe,QAAQ;MACrBjB,UAAU,IAAIoB,WAAW,GAAGF,aAAa;MAEzC,IAAId,WAAW,KAAKgB,WAAW,EAAE;QAC/BhB,WAAW,GAAGgB,WAAW;QACzB,IAAIF,aAAa,KAAKE,WAAW,EAAE;UACjCf,YAAY,GAAGY,QAAQ;QACzB,CAAC,MAAM;UACLZ,YAAY,GACVS,SAAS,CAACzB,GAAG,CAACY,KAAK,CAACK,MAAM,GAC1BM,aAAa,CAACvB,GAAG,CAAC8B,GAAG,CAACb,MAAM,GAC5BS,eAAe;QACnB;MACF,CAAC,MAAM;QACLV,YAAY,IAAIY,QAAQ;MAC1B;IACF;EACF;EAEA,IAAII,iBAAiB,GAAG,CAAC;EAEzB,IAAI/B,gBAAgB,EAAE;IACpB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAInB,GAAG,CAACQ,IAAI,EAAEW,CAAC,EAAE,EAAE;MAAA;MAClCa,iBAAiB,8BAAI/B,gBAAgB,CAACM,GAAG,CAACY,CAAC,CAAC,2EAAI,CAAC;IACnD;EACF;EAEAnB,GAAG,CAACQ,IAAI,IAAIG,UAAU;EACtB,IAAIX,GAAG,CAACQ,IAAI,KAAKO,WAAW,EAAE;IAC5Bf,GAAG,CAACiB,MAAM,IAAID,YAAY;EAC5B;EACAhB,GAAG,CAACiB,MAAM,IAAIX,eAAe;EAE7BN,GAAG,CAACc,MAAM,GAAGD,SAAS,GAAGmB,iBAAiB;EAE1C,OAAOhC,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiC,sBAAsB,CAC7BC,KAAa,EACbC,UAAkB,EAClBlC,gBAAsC,EAC9B;EACR,IAAI,CAACiC,KAAK,CAACE,QAAQ,CAAC,IAAI,CAAC,EAAE;IACzB,MAAM9B,eAAe,GAAGL,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEM,GAAG,CAAC4B,UAAU,CAAC;IACzD,IAAI7B,eAAe,KAAK+B,SAAS,EAAE;MACjC,OAAO,GAAG,CAACC,MAAM,CAAChC,eAAe,CAAC,GAAG4B,KAAK;IAC5C;IACA,OAAOA,KAAK;EACd;EAEA,MAAMhB,KAAK,GAAGgB,KAAK,CAACK,KAAK,CAAC,IAAI,CAAC;EAC/B,MAAMC,QAAkB,GAAG,EAAE;EAE7B,IAAItB,KAAK,CAAC,CAAC,CAAC,KAAKmB,SAAS,EAAE;IAC1BG,QAAQ,CAACC,IAAI,CAACvB,KAAK,CAAC,CAAC,CAAC,CAAC;EACzB;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;IACrC,MAAMX,IAAI,GAAGU,KAAK,CAACC,CAAC,CAAC;IACrB,IAAIX,IAAI,KAAK6B,SAAS,EAAE;MACtB,MAAMK,iBAAiB,GAAGP,UAAU,GAAGhB,CAAC;MACxC,MAAMb,eAAe,GAAGL,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEM,GAAG,CAACmC,iBAAiB,CAAC;MAEhE,IAAIpC,eAAe,KAAK+B,SAAS,EAAE;QACjCG,QAAQ,CAACC,IAAI,CAAC,GAAG,CAACH,MAAM,CAAChC,eAAe,CAAC,GAAGE,IAAI,CAAC;MACnD,CAAC,MAAM;QACLgC,QAAQ,CAACC,IAAI,CAACjC,IAAI,CAAC;MACrB;IACF;EACF;EAEA,OAAOgC,QAAQ,CAACG,IAAI,CAAC,IAAI,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwB,CAC/B7C,IAAO,EACP8C,GAAY,EACZ5C,gBAAsC,EACvB;EAAA;EACf,MAAMiC,KAAK,GAAGnC,IAAI,CAAC8C,GAAG,CAAC;EAEvB,IAAI,OAAOX,KAAK,KAAK,QAAQ,IAAI,kBAACnC,IAAI,CAAC+C,MAAM,yCAAX,aAAalC,KAAK,GAAE;IACpD,OAAO,IAAI;EACb;EAEA,OAAOqB,sBAAsB,CAC3BC,KAAK,EACLnC,IAAI,CAAC+C,MAAM,CAAClC,KAAK,CAACJ,IAAI,EACtBP,gBAAgB,CACjB;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8C,kBAAkB,CACzBhD,IAAiC,EACjCE,gBAAqC,EAC/B;EAAA;EACN,IACEF,IAAI,CAACiD,IAAI,CAACC,MAAM,KACflD,IAAI,CAACiD,IAAI,CAACC,MAAM,CAACb,QAAQ,CAAC,IAAI,CAAC,IAAI,iBAAArC,IAAI,CAACmD,MAAM,iDAAX,aAAaC,IAAI,MAAK,MAAM,CAAC,qBACjEpD,IAAI,CAAC+C,MAAM,0CAAX,cAAalC,KAAK,EAClB;IACA,MAAMwC,cAAc,GAAGrD,IAAI,CAACiD,IAAI,CAACC,MAAM,CAACV,KAAK,CAAC,IAAI,CAAC,CAAClB,MAAM,GAAG,CAAC;IAC9D,MAAMgC,SAAS,GAAGpB,sBAAsB,CACtClC,IAAI,CAACiD,IAAI,CAACC,MAAM,EAChBlD,IAAI,CAAC+C,MAAM,CAAClC,KAAK,CAACJ,IAAI,GAAG4C,cAAc,EACvCnD,gBAAgB,CACjB;IACDF,IAAI,CAACiD,IAAI,CAACM,aAAa,GAAGD,SAAS;EACrC;EAEA,IACEtD,IAAI,CAACiD,IAAI,CAACO,KAAK,IACfxD,IAAI,CAACiD,IAAI,CAACO,KAAK,CAACnB,QAAQ,CAAC,IAAI,CAAC,KAC7BrC,IAAI,CAACoD,IAAI,KAAK,MAAM,qBAAIpD,IAAI,CAAC+C,MAAM,0CAAX,cAAahB,GAAG,CAAC,EAC1C;IAAA;IACA,MAAM0B,aAAa,GAAGzD,IAAI,CAACiD,IAAI,CAACO,KAAK,CAAChB,KAAK,CAAC,IAAI,CAAC,CAAClB,MAAM,GAAG,CAAC;IAC5D,MAAMb,IAAI,GACRT,IAAI,CAACoD,IAAI,KAAK,MAAM,kBAChBpD,IAAI,CAAC0D,KAAK,CAAC1D,IAAI,CAAC0D,KAAK,CAACpC,MAAM,GAAG,CAAC,CAAC,sEAAjC,YAAmCyB,MAAM,gFAAzC,mBAA2ChB,GAAG,0DAA9C,sBAAgDtB,IAAI,oBACpDT,IAAI,CAAC+C,MAAM,uEAAX,cAAahB,GAAG,sDAAhB,kBAAkBtB,IAAI;IAC5B,IAAIA,IAAI,KAAK6B,SAAS,EAAE;MACtB,MAAMgB,SAAS,GAAGpB,sBAAsB,CACtClC,IAAI,CAACiD,IAAI,CAACO,KAAK,EACf/C,IAAI,GAAGgD,aAAa,EACpBvD,gBAAgB,CACjB;MACDF,IAAI,CAACiD,IAAI,CAACU,YAAY,GAAGL,SAAS;IACpC;EACF;EAEA,IACEtD,IAAI,CAACiD,IAAI,CAACW,OAAO,IACjB5D,IAAI,CAACiD,IAAI,CAACW,OAAO,CAACvB,QAAQ,CAAC,IAAI,CAAC,qBAChCrC,IAAI,CAAC+C,MAAM,0CAAX,cAAalC,KAAK,EAClB;IACA,MAAMyC,SAAS,GAAGpB,sBAAsB,CACtClC,IAAI,CAACiD,IAAI,CAACW,OAAO,EACjB5D,IAAI,CAAC+C,MAAM,CAAClC,KAAK,CAACJ,IAAI,EACtBP,gBAAgB,CACjB;IAEDF,IAAI,CAACiD,IAAI,CAACY,cAAc,GAAGP,SAAS;EACtC;EAEA,IAAItD,IAAI,CAACoD,IAAI,KAAK,MAAM,IAAIpD,IAAI,CAAC8D,QAAQ,CAACzB,QAAQ,CAAC,IAAI,CAAC,EAAE;IACxD,MAAM0B,QAAQ,GAAGlB,wBAAwB,CACvC7C,IAAI,EACJ,UAAU,EACVE,gBAAgB,CACjB;IAED,IAAI6D,QAAQ,KAAK,IAAI,EAAE;MACpB/D,IAAI,CAACiD,IAAI,CAAwCe,eAAe,GAC/DD,QAAQ;IACZ;EACF;EAEA,IAAI/D,IAAI,CAACoD,IAAI,KAAK,MAAM,IAAIpD,IAAI,CAACmC,KAAK,CAACE,QAAQ,CAAC,IAAI,CAAC,EAAE;IACrD,MAAM0B,QAAQ,GAAGlB,wBAAwB,CAAC7C,IAAI,EAAE,OAAO,EAAEE,gBAAgB,CAAC;IAE1E,IAAI6D,QAAQ,KAAK,IAAI,EAAE;MACpB/D,IAAI,CAACiD,IAAI,CAAwCgB,YAAY,GAAGF,QAAQ;IAC3E;EACF;EAEA,IAAI/D,IAAI,CAACoD,IAAI,KAAK,QAAQ,IAAIpD,IAAI,CAACkE,MAAM,CAAC7B,QAAQ,CAAC,IAAI,CAAC,EAAE;IACxD,MAAM0B,QAAQ,GAAGlB,wBAAwB,CAAC7C,IAAI,EAAE,QAAQ,EAAEE,gBAAgB,CAAC;IAE3E,IAAI6D,QAAQ,KAAK,IAAI,EAAE;MACpB/D,IAAI,CAACiD,IAAI,CAAwCkB,aAAa,GAC7DJ,QAAQ;IACZ;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASK,wBAAwB,CACtC7C,IAA8B,EAC9BpB,cAAsB,EACuB;EAC7C,OAAQH,IAAiC,IAAW;IAAA;IAClD,MAAMqE,IAAI,GAAGrE,IAAI,CAACqE,IAAI,EAAE;IACxB,MAAMnE,gBAAgB,GAAGmE,IAAI,CAACpB,IAAI,CAACqB,uBAAuB;IAE1D,IAAIpE,gBAAgB,EAAE;MACpB8C,kBAAkB,CAAChD,IAAI,EAAEE,gBAAgB,CAAC;IAC5C;IAEA,qBAAIF,IAAI,CAAC+C,MAAM,0CAAX,cAAalC,KAAK,EAAE;MACtBb,IAAI,CAAC+C,MAAM,CAAClC,KAAK,GAAGd,eAAe,CACjCwB,IAAI,EACJvB,IAAI,CAAC+C,MAAM,CAAClC,KAAK,EACjBX,gBAAgB,EAChBC,cAAc,EACdkE,IAAI,CAACpB,IAAI,CAACsB,oBAAoB,CAC/B;IACH;IACA,qBAAIvE,IAAI,CAAC+C,MAAM,0CAAX,cAAahB,GAAG,EAAE;MACpB/B,IAAI,CAAC+C,MAAM,CAAChB,GAAG,GAAGhC,eAAe,CAC/BwB,IAAI,EACJvB,IAAI,CAAC+C,MAAM,CAAChB,GAAG,EACf7B,gBAAgB,EAChBC,cAAc,EACdkE,IAAI,CAACpB,IAAI,CAACsB,oBAAoB,CAC/B;IACH;EACF,CAAC;AACH"}