{"version":3,"file":"parse.js","names":["parse","babelParse","traverse","Document","Input","postcssParse","locationCorrectionWalker","createPlaceholder","generateStyleTextWithExpressionPlaceholders","node","sourceAsString","styleText","expressionStrings","i","quasi","quasis","length","template","expr","expressions","nextTemplate","value","raw","range","exprText","slice","push","getDeindentedStyleTextAndOffsets","baseIndentation","loc","end","column","sourceLines","split","baseIndentations","Map","indentationPattern","RegExp","emptyLinePattern","deindentedLines","prefixOffsets","lines","offset","undefined","test","shift","sourceLine","replace","set","deindentedStyleText","join","source","opts","doc","toString","ast","sourceType","plugins","ranges","extractedStyles","Set","TaggedTemplateExpression","path","tag","type","name","includes","add","object","currentOffset","startIndex","root","map","raws","linariaPrefixOffsets","linariaTemplateExpressions","linariaBaseIndentations","beforeStart","codeBefore","parent","document","walker","walk","nodes","last","codeAfter","input","start","line"],"sources":["../src/parse.ts"],"sourcesContent":["import { parse as babelParse } from '@babel/parser';\nimport type { NodePath } from '@babel/traverse';\nimport traverse from '@babel/traverse';\nimport type { Identifier, TaggedTemplateExpression } from '@babel/types';\nimport type { Parser, Root, ProcessOptions } from 'postcss';\nimport { Document, Input } from 'postcss';\nimport postcssParse from 'postcss/lib/parse';\n\nimport { locationCorrectionWalker } from './locationCorrection';\nimport { createPlaceholder } from './util';\n\n// This function returns\n// 1) styleText with placeholders for the expressions.\n//    for example:\n//      `${selector} { ${property} : ${value} }`\n//    becomes\n//      `.pcss-lin0 { --pcss-lin1: pcss-lin2 }`\n// 2) an array of the expressions:\n// ['${selector}', '${property}', '${value}']\nconst generateStyleTextWithExpressionPlaceholders = (\n  node: TaggedTemplateExpression,\n  sourceAsString: string\n): { styleText: string; expressionStrings: string[] } => {\n  let styleText = '';\n  const expressionStrings: string[] = [];\n\n  for (let i = 0; i < node.quasi.quasis.length; i++) {\n    const template = node.quasi.quasis[i];\n    const expr = node.quasi.expressions[i];\n    const nextTemplate = node.quasi.quasis[i + 1];\n    if (template) {\n      styleText += template.value.raw;\n\n      if (expr && nextTemplate && nextTemplate.range && template.range) {\n        const exprText = sourceAsString.slice(\n          template.range[1],\n          nextTemplate.range[0]\n        );\n        styleText += createPlaceholder(\n          i,\n          sourceAsString,\n          nextTemplate.range[0]\n        );\n        expressionStrings.push(exprText);\n      }\n    }\n  }\n  return { styleText, expressionStrings };\n};\n\nconst getDeindentedStyleTextAndOffsets = (\n  styleText: string,\n  node: TaggedTemplateExpression\n) => {\n  const baseIndentation = (node.quasi.loc?.end.column ?? 1) - 1;\n  const sourceLines = styleText.split('\\n');\n  const baseIndentations = new Map<number, number>();\n  const indentationPattern = new RegExp(`^[ \\\\t]{${baseIndentation}}`);\n  const emptyLinePattern = /^[ \\\\t\\r]*$/;\n  const deindentedLines: string[] = [];\n  const prefixOffsets = { lines: 0, offset: 0 };\n\n  // remove the first line if it's an empty string and update the prefix\n  // offset to be the lines 1 instead of lines 0\n  if (\n    sourceLines.length > 1 &&\n    sourceLines[0] !== undefined &&\n    emptyLinePattern.test(sourceLines[0])\n  ) {\n    prefixOffsets.lines = 1;\n    prefixOffsets.offset = sourceLines[0].length + 1;\n    sourceLines.shift();\n  }\n\n  // go through each source line and deindent lines\n  for (let i = 0; i < sourceLines.length; i++) {\n    const sourceLine = sourceLines[i];\n    if (sourceLine !== undefined) {\n      // if the sourceline has the indentation pattern\n      if (indentationPattern.test(sourceLine)) {\n        deindentedLines.push(sourceLine.replace(indentationPattern, ''));\n        baseIndentations.set(i + 1, baseIndentation);\n        // Roots don't have an end line, so we can't look this up so easily\n        // later on. Having a special '-1' key helps here.\n        if (i === sourceLines.length - 1) {\n          baseIndentations.set(-1, baseIndentation);\n        }\n      } else {\n        deindentedLines.push(sourceLine);\n      }\n    }\n  }\n\n  const deindentedStyleText = deindentedLines.join('\\n');\n  return { deindentedStyleText, prefixOffsets, baseIndentations };\n};\n\n/**\n * Parses CSS from within tagged template literals in a JavaScript document\n * @param {string} source Source code to parse\n * @param {*=} opts Options to pass to PostCSS' parser when parsing\n * @return {Root|Document}\n */\nexport const parse: Parser<Root | Document> = (\n  source: string | { toString(): string },\n  opts?: Pick<ProcessOptions, 'map' | 'from'>\n): Root | Document => {\n  const doc = new Document();\n  const sourceAsString = source.toString();\n\n  // avoid error spam (and vscode error toasts) if babel can't parse doc\n  // allows user to type new code without constant warnings\n  let ast;\n  try {\n    ast = babelParse(sourceAsString, {\n      sourceType: 'unambiguous',\n      plugins: ['typescript', 'jsx'],\n      ranges: true,\n    });\n  } catch {\n    return doc;\n  }\n  const extractedStyles = new Set<TaggedTemplateExpression>();\n\n  traverse(ast, {\n    TaggedTemplateExpression: (\n      path: NodePath<TaggedTemplateExpression>\n    ): void => {\n      if (\n        path.node.tag.type === 'Identifier' &&\n        path.node.tag.name.includes('css')\n      ) {\n        extractedStyles.add(path.node);\n      }\n\n      if (path.node.tag.type === 'MemberExpression') {\n        if ((path.node.tag.object as Identifier).name === 'styled') {\n          extractedStyles.add(path.node);\n        }\n      }\n    },\n  });\n\n  let currentOffset = 0;\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const node of extractedStyles) {\n    if (!node.quasi.range) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    const startIndex = node.quasi.range[0] + 1;\n\n    const { styleText, expressionStrings } =\n      generateStyleTextWithExpressionPlaceholders(node, sourceAsString);\n\n    const { deindentedStyleText, prefixOffsets, baseIndentations } =\n      getDeindentedStyleTextAndOffsets(styleText, node);\n\n    const root = postcssParse(deindentedStyleText, {\n      ...opts,\n      map: false,\n    }) as Root;\n\n    root.raws.linariaPrefixOffsets = prefixOffsets;\n    root.raws.linariaTemplateExpressions = expressionStrings;\n    root.raws.linariaBaseIndentations = baseIndentations;\n    // TODO: remove this if stylelint/stylelint#5767 ever gets fixed,\n    // or they drop the indentation rule. Their indentation rule depends on\n    // `beforeStart` existing as they unsafely try to call `endsWith` on it.\n    if (!root.raws.beforeStart) {\n      root.raws.beforeStart = '';\n    }\n    root.raws.codeBefore = sourceAsString.slice(\n      currentOffset,\n      startIndex + prefixOffsets.offset\n    );\n    root.parent = doc;\n    // TODO: stylelint relies on this existing, really unsure why.\n    // it could just access root.parent to get the document...\n    (root as Root & { document: Document }).document = doc;\n    const walker = locationCorrectionWalker(node, sourceAsString);\n    walker(root);\n    root.walk(walker);\n    doc.nodes.push(root);\n\n    currentOffset = node.quasi.range[1] - 1;\n  }\n\n  if (doc.nodes.length > 0) {\n    const last = doc.nodes[doc.nodes.length - 1];\n    if (last) {\n      last.raws.codeAfter = sourceAsString.slice(currentOffset);\n    }\n  }\n\n  doc.source = {\n    input: new Input(sourceAsString, opts),\n    start: {\n      line: 1,\n      column: 1,\n      offset: 0,\n    },\n  };\n\n  return doc;\n};\n"],"mappings":"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"}