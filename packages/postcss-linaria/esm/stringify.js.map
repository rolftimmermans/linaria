{"version":3,"file":"stringify.js","names":["Stringifier","placeholderText","substitutePlaceholders","stringWithPlaceholders","expressions","includes","values","split","temp","forEach","val","expressionIndexString","suffix","Number","isNaN","length","slice","expressionIndex","expression","push","join","LinariaStringifier","constructor","builder","wrappedBuilder","str","node","type","replace","comment","placeholderPattern","RegExp","test","text","root","expressionStrings","raws","linariaTemplateExpressions","decl","semicolon","between","raw","prop","value","rawValue","string","important","document","nodes","source","input","css","codeBefore","body","after","linariaAfter","codeAfter","rule","block","ownSemicolon","own","detect","before","linariaBefore","linariaBetween","linariaProp","toUpperCase","Object","prototype","hasOwnProperty","call","stringify"],"sources":["../src/stringify.ts"],"sourcesContent":["import type {\n  Stringifier as StringifierFn,\n  Comment,\n  Root,\n  Document,\n  AnyNode,\n  Builder,\n  Declaration,\n  Rule,\n} from 'postcss';\nimport Stringifier from 'postcss/lib/stringifier';\n\nimport { placeholderText } from './util';\n\nconst substitutePlaceholders = (\n  stringWithPlaceholders: string,\n  expressions: string[]\n) => {\n  if (!stringWithPlaceholders.includes(placeholderText) || !expressions) {\n    return stringWithPlaceholders;\n  }\n\n  const values = stringWithPlaceholders.split(' ');\n  const temp: string[] = [];\n  values.forEach((val) => {\n    let [, expressionIndexString] = val.split(placeholderText);\n    // if the val is 'pcss-lin10px', need to remove the px to get the placeholder number\n    let suffix = '';\n    while (\n      Number.isNaN(Number(expressionIndexString)) &&\n      expressionIndexString &&\n      expressionIndexString.length > 0\n    ) {\n      suffix = expressionIndexString[expressionIndexString.length - 1] + suffix;\n      expressionIndexString = expressionIndexString.slice(\n        0,\n        expressionIndexString.length - 1\n      );\n    }\n    const expressionIndex = Number(expressionIndexString);\n    const expression =\n      expressions &&\n      !Number.isNaN(expressionIndex) &&\n      expressions[expressionIndex];\n    if (expression) {\n      temp.push(expression + suffix);\n    } else {\n      temp.push(val);\n    }\n  });\n  return temp.join(' ');\n};\n\n/**\n * Stringifies PostCSS nodes while taking interpolated expressions\n * into account.\n */\nclass LinariaStringifier extends Stringifier {\n  /** @inheritdoc */\n  public constructor(builder: Builder) {\n    const wrappedBuilder: Builder = (\n      str: string,\n      node?: AnyNode,\n      type?: 'start' | 'end'\n    ): void => {\n      // We purposely ignore the root node since the only thing we should\n      // be stringifying here is already JS (before/after raws) so likely\n      // already contains backticks on purpose.\n      //\n      // Similarly, if there is no node, we're probably stringifying\n      // pure JS which never contained any CSS. Or something really weird\n      // we don't want to touch anyway.\n      //\n      // For everything else, we want to escape backticks.\n      if (!node || node?.type === 'root') {\n        builder(str, node, type);\n      } else {\n        builder(str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`'), node, type);\n      }\n    };\n    super(wrappedBuilder);\n  }\n\n  /** @inheritdoc */\n  public override comment(node: Comment): void {\n    const placeholderPattern = new RegExp(`^${placeholderText}:\\\\d+$`);\n    if (placeholderPattern.test(node.text)) {\n      const [, expressionIndexString] = node.text.split(':');\n      const expressionIndex = Number(expressionIndexString);\n      const root = node.root();\n      const expressionStrings = root.raws.linariaTemplateExpressions;\n\n      if (expressionStrings && !Number.isNaN(expressionIndex)) {\n        const expression = expressionStrings[expressionIndex];\n\n        if (expression) {\n          this.builder(expression, node);\n          return;\n        }\n      }\n    }\n\n    super.comment(node);\n  }\n\n  public override decl(node: Declaration, semicolon: boolean): void {\n    const between = this.raw(node, 'between', 'colon');\n    let { prop } = node;\n    const expressionStrings = node.root().raws.linariaTemplateExpressions;\n    if (prop.includes(placeholderText)) {\n      prop = substitutePlaceholders(prop, expressionStrings);\n    }\n\n    let value = this.rawValue(node, 'value');\n    if (value.includes(placeholderText)) {\n      value = substitutePlaceholders(value, expressionStrings);\n    }\n\n    let string = prop + between + value;\n\n    if (node.important) {\n      string += node.raws.important || ' !important';\n    }\n\n    if (semicolon) string += ';';\n    this.builder(string, node);\n  }\n\n  /** @inheritdoc */\n  public override document(node: Document): void {\n    if (node.nodes.length === 0) {\n      this.builder(node.source?.input.css ?? '');\n    } else {\n      super.document(node);\n    }\n  }\n\n  /** @inheritdoc */\n  public override root(node: Root): void {\n    this.builder(node.raws.codeBefore ?? '', node, 'start');\n\n    this.body(node);\n\n    // Here we want to recover any previously removed JS indentation\n    // if possible. Otherwise, we use the `after` string as-is.\n    const after = node.raws.linariaAfter ?? node.raws.after;\n    if (after) {\n      this.builder(after);\n    }\n\n    this.builder(node.raws.codeAfter ?? '', node, 'end');\n  }\n\n  public override rule(node: Rule): void {\n    let value = this.rawValue(node, 'selector');\n    if (value.includes(placeholderText)) {\n      const expressionStrings = node.root().raws.linariaTemplateExpressions;\n      value = substitutePlaceholders(value, expressionStrings);\n    }\n    this.block(node, value);\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end');\n    }\n  }\n\n  /** @inheritdoc */\n  public override raw(\n    node: AnyNode,\n    own: string,\n    detect: string | undefined\n  ): string {\n    if (own === 'before' && node.raws.before && node.raws.linariaBefore) {\n      return node.raws.linariaBefore;\n    }\n    if (own === 'after' && node.raws.after && node.raws.linariaAfter) {\n      return node.raws.linariaAfter;\n    }\n    if (own === 'between' && node.raws.between && node.raws.linariaBetween) {\n      return node.raws.linariaBetween;\n    }\n    return super.raw(node, own, detect);\n  }\n\n  /** @inheritdoc */\n  public override rawValue(node: AnyNode, prop: string): string {\n    const linariaProp = `linaria${prop[0]?.toUpperCase()}${prop.slice(1)}`;\n    if (Object.prototype.hasOwnProperty.call(node.raws, linariaProp)) {\n      return `${node.raws[linariaProp]}`;\n    }\n\n    return super.rawValue(node, prop);\n  }\n}\n\nexport const stringify: StringifierFn = (\n  node: AnyNode,\n  builder: Builder\n): void => {\n  const str = new LinariaStringifier(builder);\n  str.stringify(node);\n};\n"],"mappings":"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"}